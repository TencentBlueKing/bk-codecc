/*
 * Generated by code generator, see module: 'common-code-generator' for more details.
 */

package ${fullPackagePath};

import ${baseEntityImport};
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Objects;
import lombok.EqualsAndHashCode;
import org.springframework.data.annotation.Transient;
import org.springframework.data.mongodb.core.BulkOperations;
import org.springframework.data.mongodb.core.BulkOperations.BulkMode;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.data.mongodb.core.query.Criteria;
import org.springframework.data.mongodb.core.query.Query;
import org.springframework.data.mongodb.core.query.Update;

@EqualsAndHashCode(callSuper = true)
public class ${baseEntityName}Tracking extends ${baseEntityName} {

    private static final int NUMBER_OF_FIELDS = ${numberOfFields};
    private HashMap<String, Object> changesMap = null;

<#list fieldInfoList as fieldInfo>

    @Override
    public void set${fieldInfo.javaSetterName}(${fieldInfo.javaFiledType} val) {
        if (!Objects.equals(get${fieldInfo.javaSetterName}(), val)) {
            mapEntityChanges("${fieldInfo.databaseFiledName}", val);
        }

        super.set${fieldInfo.javaSetterName}(val);
    }

</#list>

    private void mapEntityChanges(String fieldName, Object fieldVal) {
        if (getEntityId() == null || getEntityId().trim().isEmpty()) {
            return;
        }

        if (changesMap == null) {
            changesMap = new HashMap<>(NUMBER_OF_FIELDS + 1, 1.0f);
        }

        changesMap.put(fieldName, fieldVal);
    }

    @Transient
    public Map<String, Object> getChangedMap() {
        return changesMap;
    }

    public static class ListContainer extends ArrayList<${baseEntityName}Tracking> {

        /**
         * 保存变更
         *
         * @mongoTemplate db provider
         */
        public void saveChanges(MongoTemplate mongoTemplate) {
            BulkOperations ops = mongoTemplate.bulkOps(BulkMode.UNORDERED, ${baseEntityName}.class);
            final boolean[] needExecute = {false};

            forEach(entity -> {
                boolean setOk = setUpdateInfo(entity, ops);
                if (setOk && !needExecute[0]) {
                    needExecute[0] = true;
                }
            });

            if (needExecute[0]) {
                ops.execute();
            }
        }

        /**
         * 分批保存变更
         *
         * @param mongoTemplate db provider
         * @param batchSize 每一批大小
         */
        public void saveChanges(MongoTemplate mongoTemplate, int batchSize) {
            if (size() <= batchSize) {
                saveChanges(mongoTemplate);
                return;
            }

            int counter = 0;
            boolean needExecute = false;
            Iterator<${baseEntityName}Tracking> iterator = iterator();
            BulkOperations ops = mongoTemplate.bulkOps(BulkMode.UNORDERED, ${baseEntityName}.class);

            while (iterator.hasNext()) {
                counter++;
                ${baseEntityName}Tracking entity = iterator.next();

                boolean setOk = setUpdateInfo(entity, ops);
                if (setOk && !needExecute) {
                    needExecute = true;
                }

                if ((counter % batchSize == 0 || size() == counter) && needExecute) {
                    ops.execute();
                    needExecute = false;
                    ops = mongoTemplate.bulkOps(BulkMode.UNORDERED, ${baseEntityName}.class);
                }
            }
        }

        private boolean setUpdateInfo(${baseEntityName}Tracking entity, BulkOperations ops) {
            if (entity.getChangedMap() == null || entity.getChangedMap().isEmpty()) {
                return false;
            }

            Query query = Query.query(Criteria.where("_id").is(entity.getEntityId()));
            Update update = new Update();
            entity.getChangedMap().forEach((key, value) -> {
                if (value != null) {
                    update.set(key, value);
                } else {
                    update.unset(key);
                }
            });

            ops.updateOne(query, update);

            return true;
        }
    }
}
