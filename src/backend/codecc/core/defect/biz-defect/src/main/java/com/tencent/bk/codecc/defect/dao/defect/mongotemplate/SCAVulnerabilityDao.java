package com.tencent.bk.codecc.defect.dao.defect.mongotemplate;

import com.google.common.base.CaseFormat;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;
import com.tencent.bk.codecc.defect.dao.SCAQueryWarningParams;
import com.tencent.bk.codecc.defect.dao.defect.mongorepository.sca.SCAVulnerabilityRepository;
import com.tencent.bk.codecc.defect.model.sca.SCASbomPackageEntity;
import com.tencent.bk.codecc.defect.model.sca.SCAVulnerabilityEntity;
import com.tencent.bk.codecc.defect.utils.ParamUtils;
import com.tencent.bk.codecc.defect.vo.sca.SCADefectGroupStatisticVO;
import com.tencent.bk.codecc.defect.vo.sca.SCADefectQueryReqVO;
import com.tencent.codecc.common.db.MongoPageHelper;
import com.tencent.devops.common.api.exception.CodeCCException;
import com.tencent.devops.common.api.pojo.Page;
import com.tencent.devops.common.constant.CommonMessageCode;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.collections.MapUtils;
import org.apache.commons.lang.StringUtils;
import org.bson.types.ObjectId;
import org.jetbrains.annotations.NotNull;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Sort;
import org.springframework.data.mongodb.core.BulkOperations;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.data.mongodb.core.aggregation.Aggregation;
import org.springframework.data.mongodb.core.aggregation.AggregationOptions;
import org.springframework.data.mongodb.core.aggregation.AggregationResults;
import org.springframework.data.mongodb.core.aggregation.GroupOperation;
import org.springframework.data.mongodb.core.aggregation.MatchOperation;
import org.springframework.data.mongodb.core.query.Criteria;
import org.springframework.data.mongodb.core.query.Query;
import org.springframework.data.mongodb.core.query.Update;
import org.springframework.stereotype.Repository;

import java.time.Duration;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * SCA工具漏洞持久层代码
 */
@Slf4j
@Repository
public class SCAVulnerabilityDao {
    public static final String COLLECTION_NAME = "t_sca_vulnerability";
    // 公共的分页大小
    private static final int PAGE_SIZE = 1000;

    @Autowired
    private MongoTemplate defectMongoTemplate;
    @Autowired
    private MongoPageHelper mongoPageHelper;
    @Autowired
    private SCAVulnerabilityRepository scaVulnerabilityRepository;

    /**
     * 分页查询SCA漏洞数据
     *
     * @param scaQueryWarningParams SCA漏洞查询参数对象，包含任务工具映射、构建ID等过滤条件
     * @param pageNum               当前页码（从1开始计数）
     * @param pageSize              每页数据量
     * @param sortField             排序字段（前端传入小驼峰格式，如"severityLevel"），默认按严重等级排序
     * @param sortType              排序方向（ASC/DESC），默认升序
     * @return 分页查询结果对象，包含漏洞列表和分页信息
     */
    public Page<SCAVulnerabilityEntity> findVulnerabilityPageByCondition(
            SCAQueryWarningParams scaQueryWarningParams,
            Integer pageNum,
            Integer pageSize,
            String sortField,
            Sort.Direction sortType
    ) {
        // 默认按照严重等级排序
        if (StringUtils.isEmpty(sortField)) {
            sortField = "severity";
        }
        if (null == sortType) {
            sortType = Sort.Direction.ASC;
        }

        // 按照"首次发现"排序
        if ("createBuildNumber".equals(sortField)) {
            sortField = "createTime";
        }

        // 把前端传入的小驼峰排序字段转换为小写下划线的数据库字段名
        String sortFieldInDb = CaseFormat.LOWER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, sortField);
        List<Sort.Order> sortList = Lists.newArrayList(new Sort.Order(sortType, sortFieldInDb));

        // 查询超时时间
        Duration timeout = Duration.ofSeconds(60L);
        // 获取db查询条件
        Query query = Query.query(getQueryCriteria(scaQueryWarningParams));

        return mongoPageHelper.pageQuery(
                query, SCAVulnerabilityEntity.class, pageSize,
                pageNum, sortList, timeout
        );
    }

    /**
     * 按条件查询SCA组件列表
     * @param scaQueryWarningParams
     * @return
     */
    public List<SCAVulnerabilityEntity> findSCASbomPackageByCondition(
            SCAQueryWarningParams scaQueryWarningParams
    ) {
        Query query = Query.query(getQueryCriteria(scaQueryWarningParams));
        return defectMongoTemplate.find(query, SCAVulnerabilityEntity.class);
    }

    /**
     * 高效游标分页查询（基于MongoDB _id的连续分页）
     * @param scaQueryWarningParams 查询条件
     * @param lastObjectId 上一页最后记录的ObjectId（null表示第一页）
     * @param pageSize 分页大小（1-1000，默认100）
     * @return 当前页数据（按_id升序排列）
     */
    public List<SCAVulnerabilityEntity> findDefectByConditionWithEntityIdPage(
            SCAQueryWarningParams scaQueryWarningParams,
            String lastObjectId,
            Integer pageSize
    ) {
        final Query query = Query.query(getQueryCriteria(scaQueryWarningParams));

        // 1. 游标分页条件
        if (StringUtils.isNotBlank(lastObjectId)) {
            if (!ObjectId.isValid(lastObjectId)) {
                throw new CodeCCException(CommonMessageCode.PARAMETER_IS_INVALID, new String[]{lastObjectId}, null);
            }
            query.addCriteria(Criteria.where("_id").gt(new ObjectId(lastObjectId)));
        }

        // 2. 分页参数校验和设置
        int validatedPageSize = (pageSize == null || pageSize <= 0) ? 100 : Math.min(pageSize, 1000);
        query.with(Sort.by(Sort.Direction.ASC, "_id"))
                .limit(validatedPageSize);

        // 3. 执行查询
        return defectMongoTemplate.find(query, SCAVulnerabilityEntity.class);
    }

    public List<SCAVulnerabilityEntity> findByTaskIdAndToolNameAndAffectedPackageId(
            Long taskId,
            String toolName,
            List<String> packageIds
    ) {
        Query query = new Query();
        query.addCriteria(Criteria.where("task_id").is(taskId));
        query.addCriteria(Criteria.where("tool_name").is(toolName));
        query.addCriteria(Criteria.where("affected_packages.package_id").in(packageIds));

        return defectMongoTemplate.find(query, SCAVulnerabilityEntity.class);
    }

    /**
     * 查询SCA漏洞的作者列表
     * @param scaQueryWarningParams
     * @return
     */
    public List<String> findAuthorsByCondition(
            SCAQueryWarningParams scaQueryWarningParams
    ) {
        // 1. 构建基础查询条件并排除空作者
        Criteria criteria = getQueryCriteria(scaQueryWarningParams)
                .and("author").ne(null);

        // 2. 直接使用distinct查询去重
        return defectMongoTemplate.findDistinct(
                Query.query(criteria),
                "author",
                COLLECTION_NAME,
                String.class
        );
    }

    /**
     * 分组查询添加筛选条件后的各状态等级告警
     * @param scaQueryWarningParams
     * @return
     */
    public List<SCADefectGroupStatisticVO> statisticByStatus(
            SCAQueryWarningParams scaQueryWarningParams
    ) {
        SCADefectQueryReqVO request = scaQueryWarningParams.getScaDefectQueryReqVO();
        request.setStatus(null);
        scaQueryWarningParams.setScaDefectQueryReqVO(request);
        // 获取db查询条件
        Criteria criteria = getQueryCriteria(scaQueryWarningParams);

        MatchOperation match = Aggregation.match(criteria);
        // 以status进行分组
        GroupOperation group = Aggregation.group("task_id", "tool_name", "status")
                .last("status").as("status")
                .count().as("defectCount");
        AggregationOptions options = Aggregation.newAggregationOptions().allowDiskUse(true).build();
        Aggregation agg = Aggregation.newAggregation(match, group).withOptions(options);
        AggregationResults<SCADefectGroupStatisticVO> queryResult =
                defectMongoTemplate.aggregate(
                        agg,
                        "t_sca_vulnerability",
                        SCADefectGroupStatisticVO.class
                );

        return queryResult.getMappedResults();
    }

    /**
     * 分组查询添加筛选条件后的各风险等级告警
     * @param scaQueryWarningParams
     * @return
     */
    public List<SCADefectGroupStatisticVO> statisticBySeverity(
            SCAQueryWarningParams scaQueryWarningParams
    ) {
        // 获取db查询条件
        Criteria criteria = getQueryCriteria(scaQueryWarningParams);

        MatchOperation match = Aggregation.match(criteria);

        // 以severity进行分组
        GroupOperation group = Aggregation.group("task_id", "tool_name", "severity")
                .last("severity").as("severity")
                .count().as("defectCount");
        AggregationOptions options = Aggregation.newAggregationOptions().allowDiskUse(true).build();
        Aggregation agg = Aggregation.newAggregation(match, group).withOptions(options);
        AggregationResults<SCADefectGroupStatisticVO> queryResult =
                defectMongoTemplate.aggregate(
                        agg,
                        "t_sca_vulnerability",
                        SCADefectGroupStatisticVO.class
                );

        return queryResult.getMappedResults();
    }

    @NotNull
    private Criteria getQueryCriteria(
            SCAQueryWarningParams scaQueryWarningParams
    ) {
        Map<Long, List<String>> taskToolMap = scaQueryWarningParams.getTaskToolMap();
        SCADefectQueryReqVO request = scaQueryWarningParams.getScaDefectQueryReqVO();

        // 过滤条件
        String buildId = request.getBuildId();
        Boolean direct = request.getDirect();
        List<String> authors = request.getAuthors();
        List<String> languageList = request.getLanguageList();
        Set<String> status = request.getStatus();
        String keyWord = request.getKeyword();
        Set<Integer> severity =
                ParamUtils.convertStringSet2IntegerSet(request.getSeverity());

        Criteria magicEmptyCriteria = Criteria.where("task_id").is(-1L);

        if (MapUtils.isEmpty(taskToolMap)) {
            return magicEmptyCriteria;
        }

        if (StringUtils.isNotEmpty(buildId)
                && CollectionUtils.isEmpty(scaQueryWarningParams.getScaDefectMongoIdSet())
        ) {
            return magicEmptyCriteria;
        }

        // 过滤条件: 任务id-工具
        Criteria taskToolCriteria = null;
        if (taskToolMap.size() == 1) {
            Map.Entry<Long, List<String>> kv = taskToolMap.entrySet().stream().findFirst().get();
            taskToolCriteria = Criteria.where("task_id").is(kv.getKey()).and("tool_name").in(kv.getValue());
        } else {
            // 若任务对应的工具均是一致的
            boolean isEqual = true;
            Set<String> toolNameSet = Sets.newHashSet(taskToolMap.values().iterator().next());
            for (List<String> toolNameList : taskToolMap.values()) {
                if (toolNameList.size() != toolNameSet.size() || !toolNameSet.containsAll(toolNameList)) {
                    isEqual = false;
                    break;
                }
            }
            if (isEqual) {
                taskToolCriteria = Criteria.where("task_id").in(taskToolMap.keySet())
                        .and("tool_name").in(toolNameSet);
            }
        }
        if (taskToolCriteria == null) {
            taskToolCriteria = new Criteria();
            List<Criteria> innerOrOpList = Lists.newArrayList();
            for (Map.Entry<Long, List<String>> entry : taskToolMap.entrySet()) {
                Long taskId = entry.getKey();
                List<String> toolNameList = entry.getValue();
                innerOrOpList.add(
                        Criteria.where("task_id").is(taskId)
                                .and("tool_name").in(toolNameList)
                );
            }
            taskToolCriteria.orOperator(innerOrOpList.toArray(new Criteria[]{}));
        }

        List<Criteria> andOpList = Lists.newArrayList();
        andOpList.add(taskToolCriteria);

        // 过滤条件：快照buildId，对应的告警Id集合过滤
        Set<String> scaDefectMongoIdSet = scaQueryWarningParams.getScaDefectMongoIdSet();
        if (CollectionUtils.isNotEmpty(scaDefectMongoIdSet)) {
            andOpList.add(
                    Criteria.where("_id")
                            .in(scaDefectMongoIdSet.stream().map(ObjectId::new).collect(Collectors.toSet()))
            );
        }

        // 过滤条件：依赖方式direct
        if (direct != null) {
            andOpList.add(Criteria.where("direct").is(direct));
        }

        // 过滤条件：处理人authors
        if (CollectionUtils.isNotEmpty(authors)) {
            andOpList.add(Criteria.where("author").in(authors));
        }

        // 过滤条件：语言列表languageList
        if (CollectionUtils.isNotEmpty(languageList)) {
            andOpList.add(Criteria.where("language").in(languageList));
        }

        // 过滤条件：按创建日期范围过滤[startCreateTime,endCreateTime]
        Criteria creatTimeCri = ParamUtils.getStartEndTimeStampCri("line_update_time",
                request.getStartCreateTime(), request.getEndCreateTime());
        if (creatTimeCri != null) {
            andOpList.add(creatTimeCri);
        }

        // 过滤条件：按修复日期范围过滤[startFixTime,endFixTime]
        Criteria fixTimeCri = ParamUtils.getStartEndTimeStampCri("fixed_time",
                request.getStartFixTime(), request.getEndFixTime());
        if (fixTimeCri != null) {
            andOpList.add(fixTimeCri);
        }

        // 过滤条件：状态status
        if (CollectionUtils.isNotEmpty(status)) {
            Set<Integer> statusInteger = ParamUtils.convertStringSet2IntegerSet(status);
            boolean isSnapshotQuery = StringUtils.isNotEmpty(request.getBuildId());
            Set<Integer> ignoreReasonTypes = request.getIgnoreReasonTypes();
            Criteria statusCriteria =
                    ParamUtils.getStatusCriteria(statusInteger, isSnapshotQuery, ignoreReasonTypes);
            andOpList.add(statusCriteria);
        }

        // 过滤条件：按风险等级过滤
        if (CollectionUtils.isNotEmpty(severity)) {
            andOpList.add(Criteria.where("severity").in(severity));
        }

        // 过滤条件：组件名关键词keyWord
        if (StringUtils.isNotBlank(keyWord)) {
            andOpList.add(Criteria.where("package_name").regex(keyWord));
        }

        // 默认过滤条件：漏洞被组件的引用状态
        andOpList.add(Criteria.where("has_enabled_package").is(true));

        return new Criteria().andOperator(andOpList.toArray(new Criteria[0]));
    }

    /**
     * 批量更新告警状态的ignore位
     *
     * @param defectList
     * @param ignoreReasonType
     * @param ignoreReason
     * @param ignoreAuthor
     */
    public void batchUpdateDefectStatusIgnoreBit(
            long taskId,
            List<SCAVulnerabilityEntity> defectList,
            int ignoreReasonType,
            String ignoreReason,
            String ignoreAuthor
    ) {
        if (CollectionUtils.isNotEmpty(defectList)) {
            BulkOperations ops = defectMongoTemplate.bulkOps(BulkOperations.BulkMode.UNORDERED,
                    SCAVulnerabilityEntity.class);
            long currTime = System.currentTimeMillis();
            defectList.forEach(defectEntity -> {
                Update update = new Update();
                update.set("status", defectEntity.getStatus());
                update.set("ignore_time", currTime);
                update.set("ignore_reason_type", ignoreReasonType);
                update.set("ignore_reason", ignoreReason);
                update.set("ignore_author", ignoreAuthor);

                Query query = new Query(
                        Criteria.where("task_id").is(taskId)
                                .and("_id").is(new ObjectId(defectEntity.getEntityId()))
                );

                ops.upsert(query, update);
            });
            ops.execute();
        }
    }

    /**
     * 批量更新告警忽略原因
     * @param taskId
     * @param defectList
     * @param ignoreReasonType
     * @param ignoreReason
     */
    public void batchUpdateIgnoreType(
            long taskId,
            List<SCAVulnerabilityEntity> defectList,
            int ignoreReasonType,
            String ignoreReason
    ) {
        if (CollectionUtils.isNotEmpty(defectList)) {
            BulkOperations ops = defectMongoTemplate.bulkOps(BulkOperations.BulkMode.UNORDERED,
                    SCAVulnerabilityEntity.class);
            defectList.forEach(defectEntity -> {
                Query query = new Query();
                query.addCriteria(Criteria.where("_id").
                        is(new ObjectId(defectEntity.getEntityId())).and("task_id").is(taskId));
                Update update = new Update();
                update.set("ignore_reason_type", ignoreReasonType);
                update.set("ignore_reason", ignoreReason);
                ops.upsert(query, update);
            });
            ops.execute();
        }
    }

    /**
     * 批量更新告警的处理标记
     * @param taskId
     * @param defectList
     * @param markFlag
     */
    public void batchMarkDefect(long taskId, List<SCAVulnerabilityEntity> defectList, Integer markFlag) {
        if (CollectionUtils.isNotEmpty(defectList)) {
            BulkOperations ops = defectMongoTemplate.bulkOps(BulkOperations.BulkMode.UNORDERED,
                    SCAVulnerabilityEntity.class);
            long currTime = System.currentTimeMillis();
            defectList.forEach(defectEntity -> {
                Query query = new Query();
                query.addCriteria(
                        Criteria.where("_id").is(new ObjectId(defectEntity.getEntityId())).and("task_id").is(taskId));
                Update update = new Update();
                update.set("mark", markFlag);
                update.set("mark_time", currTime);
                ops.updateOne(query, update);
            });
            ops.execute();
        }
    }

    /**
     * 批量更新告警的处理人
     * @param taskId
     * @param defectList
     * @param newAuthor
     */
    public void batchUpdateDefectAuthor(long taskId, List<SCAVulnerabilityEntity> defectList, Set<String> newAuthor) {
        if (CollectionUtils.isNotEmpty(defectList)) {
            BulkOperations ops = defectMongoTemplate.bulkOps(BulkOperations.BulkMode.UNORDERED,
                    SCAVulnerabilityEntity.class);
            defectList.forEach(defectEntity -> {
                Query query = new Query();
                query.addCriteria(
                        Criteria.where("_id").is(new ObjectId(defectEntity.getEntityId())).and("task_id").is(taskId));
                Update update = new Update();
                update.set("author", newAuthor);
                ops.updateOne(query, update);
            });
            ops.execute();
        }
    }
}