package com.tencent.bk.codecc.defect.service.impl.sca

import com.tencent.bk.codecc.defect.dao.defect.mongorepository.sca.BuildSCAVulnerabilityRepository
import com.tencent.bk.codecc.defect.dao.defect.mongorepository.sca.SCAVulnerabilityRepository
import com.tencent.bk.codecc.defect.model.BuildEntity
import com.tencent.bk.codecc.defect.model.sca.BuildSCAVulnerabilityEntity
import com.tencent.bk.codecc.defect.model.sca.SCAVulnerabilityEntity
import com.tencent.bk.codecc.defect.service.sca.SCAVulnerabilityService
import com.tencent.devops.common.constant.ComConstants.DefectStatus
import org.apache.commons.lang3.StringUtils
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.stereotype.Service
import org.springframework.util.CollectionUtils

@Service
class SCAVulnerabilityServiceImpl @Autowired constructor(
    private val scaVulnerabilityRepository: SCAVulnerabilityRepository,
    private val buildSCAVulnerabilityRepository: BuildSCAVulnerabilityRepository
) : SCAVulnerabilityService {

    override fun getVulnerabilityByPackageNames(
        taskId: Long,
        toolName: String,
        packageNames: Collection<String>
    ): List<SCAVulnerabilityEntity> =
        scaVulnerabilityRepository.findByTaskIdAndToolNameAndPackageNameIn(taskId, toolName, packageNames)

    override fun getVulnerabilityByPackageNamesNotContain(
        taskId: Long,
        toolName: String,
        packageNames: Collection<String>
    ): List<SCAVulnerabilityEntity> =
        scaVulnerabilityRepository.findByTaskIdAndToolNameAndPackageNameNotIn(taskId, toolName, packageNames)

    override fun saveVulnerabilities(
        taskId: Long,
        toolName: String,
        vulnerabilities: Collection<SCAVulnerabilityEntity>
    ) {
        if (CollectionUtils.isEmpty(vulnerabilities)) {
            return
        }
        vulnerabilities.forEach {
            if (StringUtils.isEmpty(it.entityId)) {
                it.applyAuditInfoOnCreate()
            } else {
                it.applyAuditInfoOnUpdate()
            }
        }
        scaVulnerabilityRepository.saveAll(vulnerabilities)
    }

    override fun saveBuildVulnerabilities(
        taskId: Long,
        toolName: String,
        buildId: String,
        buildEntity: BuildEntity?,
        vulnerabilities: Collection<SCAVulnerabilityEntity>
    ) {
        if (vulnerabilities.isEmpty()) {
            return
        }
        val buildVulList = vulnerabilities.map {
            BuildSCAVulnerabilityEntity(taskId, toolName, buildId, buildEntity?.buildNo, it.entityId)
        }.toList()
        buildVulList.forEach { it.applyAuditInfoOnCreate() }
        val count = buildSCAVulnerabilityRepository.countByTaskIdAndToolNameAndBuildId(taskId, toolName, buildId)
        if (count > 0) {
            buildSCAVulnerabilityRepository.removeByTaskIdAndToolNameAndBuildId(taskId, toolName, buildId)
        }
        buildSCAVulnerabilityRepository.insert(buildVulList)
    }

    override fun getNewVulnerabilitiesFromSnapshot(
        taskId: Long,
        toolName: String,
        buildId: String
    ): List<SCAVulnerabilityEntity> {
        val buildVulList = buildSCAVulnerabilityRepository.findByTaskIdAndToolNameAndBuildId(taskId, toolName, buildId)
        if (buildVulList.isEmpty()) {
            return emptyList()
        }
        val buildVulIds = buildVulList.map { it.id }
        return scaVulnerabilityRepository.findAllById(buildVulIds).filter { it.status == DefectStatus.NEW.value() }
    }

    override fun getNewVulDefect(taskId: Long, toolName: String): List<SCAVulnerabilityEntity> =
        scaVulnerabilityRepository.findByTaskIdAndToolNameAndStatus(
            taskId,
            toolName,
            DefectStatus.NEW.value()
        )
}
